#! @PYTHON@ -tt

#
# Copyright (C) 2008 Francesco Salvestrini
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

# NOTE: Import Trace at first, in order to use traces consistently
try :
    # XXX FIXME: The ugliest way to read debug_enabled variable
    from   Trace         import *
    import Trace
except ImportError :
    # XXX FIXME: Add better error reporting ....
    print("Cannot import package's own bootstrap modules, bailing out ...")
    sys.exit(-1)
# We are now able to use Trace module facilities

# Now start importing python modules
try :
    import os
    import sys
    import traceback
    import getopt
except ImportError :
    error("Cannot import required system modules, bailing out ...")
    sys.exit(-1)

try :
    import warnings
except ImportError :
    warning("Cannot import optional system modules, continuing ...")

sys.path.append("@pkgvpythondir@")

try :
    from   Debug            import *
    from   Entry            import *
    from   Configuration    import *
    import Exceptions
    from   Commands.Command import *
except ImportError :
    error("Cannot import package's own modules, bailing out ...")
    sys.exit(-1)

try :
    import Commands
except ImportError :
    error("Cannot import package's commands ...")
    sys.exit(-1)

def hint(s) :
    print(s)
    print("Use `" + PROGRAM_NAME + " -h' for help")

def version() :
    print(PROGRAM_NAME + " (" + PACKAGE_NAME + ") " + PACKAGE_VERSION)
    print("Copyright (C) 2008 Francesco Salvestrini")
    print("")
    print("This is free software.  You may redistribute copies of it under the terms of")
    print("the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.")
    print("There is NO WARRANTY, to the extent permitted by law.")

class MainCommand(Command) :
    def __init__(self, name, format, footer) :
        Command.__init__(self, name, format, footer)

    def authors(self) :
        return [ "Francesco Salvestrini" ]

def main(arguments) :

    # Setup the configuration with some default values
    configuration = Configuration()
    configuration.add_section(PROGRAM_NAME)
    configuration.set(PROGRAM_NAME, 'colors',        True)
    configuration.set(PROGRAM_NAME, 'verbose',       False)
    configuration.set(PROGRAM_NAME, 'debug',         False)
    configuration.set(PROGRAM_NAME, 'database',      DEFAULT_DB_FILE)
    configuration.set(PROGRAM_NAME, 'configuration', DEFAULT_CFG_FILE)

    # Compute maximum command name length
    cmd_name_max_len = 0
    for cmd_name in Commands.commands.keys() :
        cmd_name_max_len = max(cmd_name_max_len, len(cmd_name))
    assert(cmd_name_max_len > 0)

    # Build the command line parser
    footer = "Commands:\n"
    for cmd_name in Commands.commands.keys() :
        #print("cmd_name          = " + cmd_name)

        cmd_instance = Commands.commands[cmd_name]
        #print("cmd_instance      = " + str(cmd_instance))
        assert(cmd_instance != None)

        assert(hasattr(cmd_instance, "description"))
        #assert(callable(cmd_instance.description))

        #cmd_description = cmd_instance.description()
        cmd_description = ""

        footer = footer + (("  %-" + str(cmd_name_max_len + 4) + "s%s")
                           %(cmd_name, cmd_description)) + "\n"

    footer = footer + "\n"
    footer = footer + \
        "See `" + PROGRAM_NAME + " COMMAND --help' " + \
        "for more information about a specific command.\n" + \
        "The program looks for configuration files in the following order:\n\n"
    for i in CFG_SEARCH_PATHS :
        # Do not use os.path.expandvars() here, we must preserve the vars name
        footer = footer + "  " + i + "\n"

    command = MainCommand("",
                          "[OPTION]... [COMMAND] [COMMAND-OPTION]...",
                          footer)
    command.add_option("-v", "--verbose",
                       action = "store_true",
                       dest   = "verbose",
                       help   = "display verbosely")
    command.add_option("-d", "--debug",
                       action = "store_true",
                       dest   = "debug",
                       help   = "enable debug mode")
    command.add_option("-n", "--dry-run",
                       action = "store_true",
                       dest   = "dry_run",
                       help   = "display operations without performing "
                       "modifications")
    command.add_option("--colors",
                       action = "store_true",
                       dest   = "colors",
                       help   = "use colors")
    command.add_option("--no-colors",
                       action = "store_false",
                       dest   = "colors",
                       help   = "do not use colors")
    command.add_option("--database",
                       action = "store",
                       type   = "string",
                       dest   = "database",
                       metavar="FILE",
                       help   = "change database file from the "
                       "default (" + DEFAULT_DB_FILE + ") "
                       "to the filename specified")
    command.add_option("--configuration",
                       action = "store",
                       type   = "string",
                       dest   = "configuration",
                       metavar="FILE",
                       help   = "change configuration file from the "
                       "default (" + DEFAULT_CFG_FILE + ") "
                       "to the filename specified")

    # Parse command line
    (opts, args) = command.parse_args(arguments[1:])

    if (opts.configuration != None and opts.configuration != "") :
        CFG_SEARCH_PATHS.append(opts.configuration)
    else :
        CFG_SEARCH_PATHS.append(DEFAULT_CFG_FILE)

    # Read all configuration files (if present). The order in the
    # CFG_SEARCH_PATHS variable is important in order to have the
    # right precedence over all files
    cfg_files = []
    try :
        cfg_files = configuration.read(os.path.expandvars(CFG_SEARCH_PATHS))
    except Configuration.ParsingError, e :
        error("Problems parsing configuration file (" + str(e) + ")")
        return 1
    except Exceptions.Configuration:
        warning("Problem reading configuration file, using defaults ...")
    except :
        bug()

    if (len(cfg_files) >= 1) :
        debug("Configuration read from `" + str(cfg_files) + "'")

    # Override configuration options with command line ones
    if (opts.colors == True) :
        configuration.set(PROGRAM_NAME, 'colors',        True)
    if (opts.verbose == True) :
        configuration.set(PROGRAM_NAME, 'verbose',       True)
    if (opts.debug == True) :
        configuration.set(PROGRAM_NAME, 'debug',         True)
    if (opts.database != None) :
        configuration.set(PROGRAM_NAME, 'database',      opts.database)
    if (opts.configuration != None) :
        configuration.set(PROGRAM_NAME, 'configuration', opts.configuration)

    # Do not save back our override
    configuration.clean()

    # Finally apply global configurations (each command will apply its own)
    if (configuration.get(PROGRAM_NAME, 'debug', raw = True) == True) :
        Trace.debug_enabled = True
        debug("Debugging enabled")

    # Start as normal now

    # Handle command related checks
    if (len(command.rargs) < 1) :
        hint("Missing command")
        return 1

    cmd_name     = command.rargs[0]
    cmd_instance = None
    try :
        cmd_instance = Commands.commands[cmd_name]
    except KeyError :
        hint("Unknown command `" + cmd_name + "'")
        return 1
    except :
        bug()
    assert(cmd_instance != None)
    debug("Command is:     `" + cmd_name + "'")

    cmd_parameters = []
    if (len(command.rargs) >= 2) :
        cmd_parameters = command.rargs[1:]
    debug("Parameters are: `" + str(cmd_parameters) + "'")

    if (configuration.get(PROGRAM_NAME, 'verbose', raw = True) == True) :
        line = cmd_name + " "
        for i in cmd_parameters :
            line = line + i
        print("Running command `" + line + "'")

    assert(hasattr(cmd_instance, "do"))
    assert(callable(cmd_instance.do))

    # Run the command
    retval = 1
    try :
        debug("Calling " + cmd_name + ".do()")
        cmd_instance.do(configuration, cmd_parameters)
        debug("Completed " + cmd_name + ".do()")
        retval = 0

    # Transform our exceptions first
    except Exceptions.ExplicitExit, e :
        debug("Exit explicitly from option parsing with code " + str(e.code()))
        retval = e.code()
    except Exceptions.EParameters, e :
        hint(e)
    except Exceptions.EBase, e :
        error(e)

    # Transform other exceptions last
    except IOError, e :
        error(e)
    except ValueError, e :
        error(e)
    except SystemExit, e:
        bug("Explicit system exit called in subcommand "
            "`" + cmd_name + "' (not allowed in subcommands)")
    except Exception, e :
        bug("Unhandled exception in subcommand "
            "`" + cmd_name + "' (" + str(e) + ")")
    except :
        bug("Unknown exception in subcommand "
            "`" + cmd_name + "' (" + str(e) + ")")

    assert(type(retval) == int)

    if (retval != 0) :
        debug("Got an error (" + str(retval) + "), bailing out ...")
        return retval
    debug("No error running command")

    # Save configuration back to file (if needed)
    if (configuration.modified()) :
        debug("Configuration changed, writing it back to file")

        filename = configuration.get(PROGRAM_NAME,'configuration')
        assert(filename != None)
        assert(filename != "")

        debug("Configuration will be stored into `" + filename + "'")
        try :
            ofp = open(filename, 'w')
            configuration.write(ofp)
            ofp.close()
        except Configuration.Error, e:
            error(e)
            return 1
        except :
            bug()

    debug("All operations completed successfully")
    return 0

if (__name__ == '__main__') :
    retval = 1
    try :
        retval = main(sys.argv)

    # We need to catch command related exceptions like we do in the subcommands
    # try-except blocks (see the main block) because we are using the same
    # class
    except Exceptions.ExplicitExit, e :
        debug("Exit explicitly from option parsing with code " + str(e.code()))
        retval = e.code()
    except Exceptions.EParameters, e :
        hint(e)
    except Exceptions.EBase, e :
        error(e)

    # AssertionError exceptions should be catched only here (in order to
    # transform all them into bug()
    except AssertionError, e :
        try :
            message = str(e)
        except TypeError :
            message = "cannot stringify assertion"
        except :
            message = "???"
        if (message != "") :
            message = "(" + message + ")"
        bug("Assertion error " + message)

    # Transform unhandled exceptions into bugs
    except Exception, e :
        try :
            message = str(e)
        except TypeError :
            message = "cannot stringify exception"
        except :
            message = "???"
        if (message != "") :
            message = "(" + message + ")"
        bug("Unhandled exception detected in main loop " + message)

    # Transform unknown exceptions into bugs too
    except :
        bug("Unknown exception detected in main loop")

    assert(type(retval) == int)

    debug("Program execution completed with return value " + str(retval))
    sys.exit(retval)
